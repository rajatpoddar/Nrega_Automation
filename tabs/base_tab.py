# tabs/base_tab.py
import tkinter
from tkinter import ttk, messagebox, filedialog
import customtkinter as ctk
import csv, os, sys, subprocess, requests, imgkit
from datetime import datetime
from fpdf import FPDF

class BaseAutomationTab(ctk.CTkFrame):
    """A base template for tabs that run automation tasks."""
    def __init__(self, parent, app_instance, automation_key: str):
        super().__init__(parent, fg_color="transparent")
        self.app = app_instance
        self.automation_key = automation_key

    # --- NEW: Centralized PDF Report Generator with Styling ---
    def generate_report_pdf(self, data, headers, col_widths, title, report_date, output_path):
        """Generates a styled PDF report with headers, footers, and colored rows."""
        
        class PDF(FPDF):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.report_title = ""
                self.report_date = ""

            def header(self):
                self.set_font('Arial', 'B', 14)
                self.cell(0, 10, self.report_title, 0, 0, 'C')
                self.set_font('Arial', '', 10)
                self.cell(0, 10, self.report_date, 0, 0, 'R')
                self.ln(15)

            def footer(self):
                self.set_y(-15)
                self.set_font('Arial', 'I', 8)
                footer_text = "Report Generated by NREGA Bot"
                self.cell(0, 10, footer_text, 0, 0, 'L')
                self.cell(0, 10, f'Page {self.page_no()}/{{nb}}', 0, 0, 'R')

        try:
            pdf = PDF(orientation='L', unit='mm', format='A4')
            pdf.report_title = title
            pdf.report_date = report_date
            pdf.alias_nb_pages()
            pdf.add_page()
            
            # Table Header
            pdf.set_font("Arial", 'B', 9)
            for i, header in enumerate(headers):
                pdf.cell(col_widths[i], 10, header, 1, 0, 'C')
            pdf.ln()

            # Table Body
            pdf.set_font("Arial", '', 8)
            for row in data:
                # Determine status color
                status = str(row[1]).upper() # Status is expected at index 1
                if "SUCCESS" in status:
                    pdf.set_text_color(34, 139, 34) # Forest Green
                else:
                    pdf.set_text_color(220, 20, 60) # Crimson Red

                # Render cells
                for i, item in enumerate(row):
                    # For the status column, draw the cell with color, others default
                    if i != 1: pdf.set_text_color(0, 0, 0)
                    pdf.cell(col_widths[i], 6, str(item).encode('latin-1', 'replace').decode('latin-1'), 1, 0)
                    if i == 1: pdf.set_text_color(0, 0, 0) # Reset color after status
                pdf.ln()

            pdf.output(output_path)
            return True
        except Exception as e:
            messagebox.showerror("PDF Export Error", f"Failed to generate PDF report.\n\nError: {e}")
            return False

    def upload_file_to_cloud(self, file_path: str, relative_path: str, content_type: str = 'image/jpeg'):
        """Uploads a given file to the user's cloud storage via the API."""
        if not self.app.license_info.get('key'):
            self.app.log_message(self.log_display, "   - Cloud Upload Skipped: No license key found.", "warning")
            return False
            
        headers = {'Authorization': f"Bearer {self.app.license_info['key']}"}
        url = f"https://license.nregabot.com/files/api/upload"
        filename = os.path.basename(file_path)

        try:
            with open(file_path, 'rb') as f:
                files = {'file': (filename, f, content_type)}
                data = {'relative_path': relative_path}
                
                response = requests.post(url, headers=headers, files=files, data=data, timeout=120)

            if response.status_code == 201:
                return True
            else:
                self.app.log_message(self.log_display, f"   - Cloud upload failed with status {response.status_code}: {response.text}", "error")
                return False
        except requests.exceptions.RequestException as e:
            self.app.log_message(self.log_display, f"   - A connection error occurred during cloud upload: {e}", "error")
            return False
        except Exception as e:
            self.app.log_message(self.log_display, f"   - An unexpected error occurred during cloud upload: {e}", "error")
            return False

    def generate_report_image(self, data: list, headers: list, title: str, report_date: str, footer: str, output_path: str):
        """Generates a styled image report from a list of data."""
        # --- MODIFIED: Dynamically find the bundled wkhtmltoimage executable ---
        try:
            # Determine the path to the executable based on the OS
            if config.OS_SYSTEM == "Windows":
                path_to_executable = resource_path(os.path.join("bin", "win", "wkhtmltoimage.exe"))
            elif config.OS_SYSTEM == "Darwin": # macOS
                path_to_executable = resource_path(os.path.join("bin", "mac", "wkhtmltoimage"))
            else: # Fallback for other systems (like Linux)
                path_to_executable = "wkhtmltoimage"

            # Check if the file exists and is executable (for macOS/Linux)
            if not os.path.exists(path_to_executable):
                 raise FileNotFoundError(f"wkhtmltoimage not found at {path_to_executable}")
            if config.OS_SYSTEM != "Windows":
                os.chmod(path_to_executable, 0o755)

            imgkit_config = imgkit.config(wkhtmltoimage=path_to_executable)

        except Exception as e:
            messagebox.showerror("Configuration Error", f"Could not configure the image export tool.\n\nError: {e}")
            return False
        # --- END MODIFICATION ---
        html_style = """
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; margin: 0; padding: 20px; }
            .report-container { background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); padding: 25px; max-width: 1200px; margin: auto; }
            .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
            h1 { color: #333; margin: 0; }
            .date { font-size: 16px; color: #555; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            th, td { padding: 10px 12px; border: 1px solid #ddd; text-align: left; font-size: 14px; }
            th { background-color: #4A4A4A; color: white; font-weight: bold; }
            tr:nth-child(even) { background-color: #f9f9f9; }
            .footer { text-align: center; margin-top: 25px; font-size: 12px; color: #888; }
            .success { color: #2E8B57; font-weight: bold; }
            .failed { color: #D22B2B; font-weight: bold; }
            .rejected { color: #E53E3E; font-weight: bold; }
        </style>
        """
        table_rows_html = ""
        for i, row in enumerate(data, 1):
            status = str(row[1]).upper()
            status_class = "success" if "SUCCESS" in status else "rejected" if "REJECT" in status else "failed"
            
            table_rows_html += "<tr>"
            table_rows_html += f"<td>{i}</td>" # Serial Number
            # Iterate through the rest of the row data
            for cell in row:
                if cell == row[1]: # Special handling for status column
                    table_rows_html += f"<td class='{status_class}'>{status}</td>"
                else:
                    table_rows_html += f"<td>{cell}</td>"
            table_rows_html += "</tr>"

        html_content = f"""
        <!DOCTYPE html>
        <html><head><meta charset="UTF-8">{html_style}</head>
        <body>
            <div class="report-container">
                <div class="header">
                    <h1>{title}</h1>
                    <div class="date">{report_date}</div>
                </div>
                <table>
                    <thead>
                        <tr><th>Sl. No.</th>{''.join(f'<th>{h}</th>' for h in headers)}</tr>
                    </thead>
                    <tbody>{table_rows_html}</tbody>
                </table>
                <p class="footer">{footer}</p>
            </div>
        </body></html>
        """
        try:
            config = None
            if sys.platform == 'darwin':
                path_to_executable = '/usr/local/bin/wkhtmltoimage'
                if os.path.exists(path_to_executable):
                    config = imgkit.config(wkhtmltoimage=path_to_executable)
            
            imgkit.from_string(html_content, output_path, options={'width': 1280, 'quality': 95}, config=config)
            return True
        except Exception as e:
            messagebox.showerror("Image Export Error", f"Failed to generate image report.\nPlease ensure 'wkhtmltoimage' is installed and accessible.\n\nError: {e}")
            return False

    def export_treeview_to_csv(self, treeview_widget: ttk.Treeview, default_filename: str):
        if not treeview_widget.get_children():
            messagebox.showinfo("No Data", "There are no results to export.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")], initialdir=self.app.get_user_downloads_path(), initialfile=default_filename, title="Save Results As")
        if not file_path: return
        try:
            with open(file_path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                headers = treeview_widget['columns']
                writer.writerow(headers)
                for item_id in treeview_widget.get_children():
                    row = treeview_widget.item(item_id)['values']
                    writer.writerow(row)
            if messagebox.askyesno("Export Successful", f"Results successfully exported to:\n{file_path}\n\nDo you want to open the file?"):
                if sys.platform == "win32": os.startfile(file_path)
                elif sys.platform == "darwin": subprocess.call(["open", file_path])
                else: subprocess.call(["xdg-open", file_path])
        except Exception as e: messagebox.showerror("Export Error", f"Failed to export data to CSV.\n\nError: {e}")

    def _create_action_buttons(self, parent_frame) -> ctk.CTkFrame:
        action_frame = ctk.CTkFrame(parent_frame, fg_color="transparent")
        action_frame.grid_columnconfigure((0, 1, 2), weight=1)
        self.start_button = ctk.CTkButton(action_frame, text="▶ Start Automation", command=self.start_automation)
        self.stop_button = ctk.CTkButton(action_frame, text="Stop", command=lambda: self.app.stop_events[self.automation_key].set(), state="disabled", fg_color="gray50")
        self.reset_button = ctk.CTkButton(action_frame, text="Reset", fg_color="transparent", border_width=2, command=self.reset_ui, text_color=("gray10", "#DCE4EE"))
        self.start_button.grid(row=0, column=0, sticky="ew", padx=(0,5))
        self.stop_button.grid(row=0, column=1, sticky="ew", padx=5)
        self.reset_button.grid(row=0, column=2, sticky='ew', padx=(5,0))
        return action_frame

    def _create_log_and_status_area(self, parent_notebook) -> ctk.CTkFrame:
        log_frame = parent_notebook.add("Logs & Status")
        log_frame.grid_columnconfigure(0, weight=1); log_frame.grid_rowconfigure(2, weight=1)
        status_bar_frame = ctk.CTkFrame(log_frame, fg_color="transparent")
        status_bar_frame.grid(row=0, column=0, sticky='ew'); status_bar_frame.grid_columnconfigure(0, weight=1)
        self.status_label = ctk.CTkLabel(status_bar_frame, text="Status: Ready")
        self.status_label.grid(row=0, column=0, sticky='ew', pady=(5,0))
        self.copy_logs_button = ctk.CTkButton(status_bar_frame, text="Copy Log", width=100, command=self.copy_logs_to_clipboard)
        self.copy_logs_button.grid(row=0, column=1, sticky='e', padx=5)
        self.progress_bar = ctk.CTkProgressBar(log_frame)
        self.progress_bar.set(0)
        self.progress_bar.grid(row=1, column=0, sticky='ew', pady=(10, 5))
        self.log_display = ctk.CTkTextbox(log_frame, state="disabled", wrap=tkinter.WORD)
        self.log_display.grid(row=2, column=0, sticky='nsew', pady=(5, 0))
        return log_frame
    
    def copy_logs_to_clipboard(self):
        log_content = self.log_display.get('1.0', tkinter.END).strip()
        if log_content: self.app.clipboard_clear(); self.app.clipboard_append(log_content); messagebox.showinfo("Copied", "Logs have been copied to the clipboard.")

    def style_treeview(self, treeview_widget: ttk.Treeview):
        style = ttk.Style()
        style.theme_use("clam")
        current_appearance = ctk.get_appearance_mode().lower()
        theme_data = ctk.ThemeManager.theme
        bg_color = theme_data["CTkFrame"]["fg_color"][0] if current_appearance == "light" else theme_data["CTkFrame"]["fg_color"][1]
        text_color = theme_data["CTkLabel"]["text_color"][0] if current_appearance == "light" else theme_data["CTkLabel"]["text_color"][1]
        header_bg = theme_data["CTkButton"]["fg_color"][0] if current_appearance == "light" else theme_data["CTkButton"]["fg_color"][1]
        selected_color = theme_data["CTkButton"]["hover_color"][0] if current_appearance == "light" else theme_data["CTkButton"]["hover_color"][1]
        fail_red_color = "#E53E3E"
        style.configure("Treeview", background=bg_color, foreground=text_color, fieldbackground=bg_color, borderwidth=0)
        style.map('Treeview', background=[('selected', selected_color)])
        style.configure("Treeview.Heading", background=header_bg, foreground=text_color, relief="flat")
        style.map("Treeview.Heading", background=[('active', selected_color)])
        treeview_widget.tag_configure('failed', foreground=fail_red_color)

    def _setup_treeview_sorting(self, treeview_widget: ttk.Treeview):
        for col in treeview_widget['columns']:
            treeview_widget.heading(col, text=col, command=lambda _col=col: self._sort_treeview_column(treeview_widget, _col, False))

    def _sort_treeview_column(self, tv, col, reverse):
        try:
            l = [(tv.set(k, col), k) for k in tv.get_children('')]
            try: l.sort(key=lambda t: float(t[0]), reverse=reverse)
            except ValueError: l.sort(key=lambda t: str(t[0]).lower(), reverse=reverse)
            for index, (val, k) in enumerate(l): tv.move(k, '', index)
            tv.heading(col, command=lambda: self._sort_treeview_column(tv, col, not reverse))
        except Exception as e: print(f"Error sorting treeview: {e}")

    def set_common_ui_state(self, running: bool):
        state = "disabled" if running else "normal"
        self.start_button.configure(state=state); self.reset_button.configure(state=state); self.stop_button.configure(state="normal" if running else "disabled")
        if hasattr(self, 'copy_logs_button'): self.copy_logs_button.configure(state=state)
        if hasattr(self, 'export_button'): self.export_button.configure(state=state) # Generic export button
        if hasattr(self, 'export_csv_button'): self.export_csv_button.configure(state=state) # Old csv button
        if running: self.progress_bar.configure(mode="indeterminate"); self.progress_bar.start()
        else: self.progress_bar.stop(); self.progress_bar.configure(mode="determinate"); self.progress_bar.set(0)

    def update_status(self, text: str, progress: float = None):
        self.status_label.configure(text=f"Status: {text}")
        if progress is not None: self.progress_bar.configure(mode="determinate"); self.progress_bar.set(progress)

    def start_automation(self): raise NotImplementedError("Child classes must implement the start_automation method.")
    def reset_ui(self): raise NotImplementedError("Child classes must implement the reset_ui method.")
